import java.nio.file.Files

buildscript {
    ext.kotlin_version = '1.3.50'

    repositories {
        jcenter()
        mavenCentral()
        maven { url "http://nexus.t1.tenet/nexus/content/repositories/public/" }
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath "com.worldapp.coverage:diff-coverage:0.4.5"
    }
}

group 'com.worldapp'

subprojects{
    apply plugin: 'kotlin'
    apply plugin: 'maven-publish'
    apply plugin: 'jacoco'
    apply plugin: 'com.worldapp.diff-coverage'

    repositories {
        jcenter()
        mavenCentral()
        mavenLocal()
    }

    dependencies {
        compile 'org.jacoco:org.jacoco.core:0.8.4'
        compile 'org.jacoco:org.jacoco.report:0.8.4'
        compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
        compile 'org.apache.logging.log4j:log4j-slf4j-impl:2.11.0'

        testImplementation 'io.kotlintest:kotlintest-runner-junit5:3.3.2'
        testImplementation "io.mockk:mockk:1.9.3.kotlin12"
    }

    compileKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }
    compileTestKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }
    sourceCompatibility = 1.8

    def subProjectName=it.name
    publishing {
        publications {
            "${subProjectName}"(MavenPublication) {
                from components.java
            }
        }
        if (project.hasProperty('nexusRepo')) {
            repositories {
                maven {
                    name 'nexus'
                    url "$nexusRepo/content/repositories/releases/"
                    credentials {
                        username = nexusUsername
                        password = nexusPassword
                    }
                }
            }
        }
    }

    tasks.matching { it.name.endsWith("PublicationToNexusRepository") }.all {
        onlyIf { project.hasProperty('release') && project.property('release').toBoolean() }
    }

    jacoco {
        toolVersion = "0.8.3"
    }

    jacocoTestReport {
        reports {
            html.enabled = true
        }
        executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")
    }

    diffCoverageReport {
        println "vcsroot.url=${rootProject.properties.get('vcsroot.url')}"
        afterEvaluate {
            println "afterEvaluate vcsroot.url=${rootProject.properties.get('vcsroot.url')}"
            diffSource.url = createDiffUrl()
        }
        reports {
            html = true
        }

        violationRules {
            minBranches = 1
            minLines = 1
            minInstructions = 1
            failOnViolation = false
        }
    }
}

ext.createDiffUrl = { ->
    println "project.hasProperty('teamcity'): ${project.hasProperty('teamcity')}"
    if(project.hasProperty('teamcity')) {
        println "vcsroot.url=${project.teamcity['vcsroot.url']}"
        println "teamcity.build.branch=${project.teamcity['teamcity.build.branch']}"
        def projectIdMatcher = project.teamcity['vcsroot.url'] =~ /http:\/\/gitlab\.t1\.tenet\/(.+)\.git/
        def buildBranchMatcher = project.teamcity["teamcity.build.branch"] =~ /merge-requests\/(\d+)(\/head)?/

        if (buildBranchMatcher.find() && projectIdMatcher.find()) {
            return "http://gitlab.t1.tenet/${projectIdMatcher.group(1)}/merge_requests/${buildBranchMatcher.group(1)}.diff"
        }
    }

    def file = Files.createTempFile(URLEncoder.encode(project.name, "UTF-8"), ".diff").toFile()
    def outputStream = file.newOutputStream()
    exec {
        commandLine 'git', 'diff', '@^..@'
        standardOutput = outputStream
    }
    outputStream.close()
    return file.toURI().toURL()
}
