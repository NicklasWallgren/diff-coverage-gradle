import java.nio.file.Files

buildscript {
    ext.kotlin_version = '1.3.50'

    repositories {
        jcenter()
        mavenCentral()
        maven { url "http://nexus.t1.tenet/nexus/content/repositories/public/" }
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath "com.worldapp.coverage:diff-coverage:0.5.0"
    }
}

apply plugin: 'com.worldapp.diff-coverage'

group 'com.worldapp'

subprojects{
    apply plugin: 'kotlin'
    apply plugin: 'maven-publish'
    apply plugin: 'jacoco'

    repositories {
        jcenter()
        mavenCentral()
        mavenLocal()
    }

    dependencies {
        compile 'org.jacoco:org.jacoco.core:0.8.4'
        compile 'org.jacoco:org.jacoco.report:0.8.4'
        compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
        compile 'org.apache.logging.log4j:log4j-slf4j-impl:2.11.0'

        testImplementation 'io.kotlintest:kotlintest-runner-junit5:3.3.2'
        testImplementation "io.mockk:mockk:1.9.3.kotlin12"
    }

    compileKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }
    compileTestKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }
    sourceCompatibility = 1.8

    def subProjectName=it.name
    publishing {
        publications {
            "${subProjectName}"(MavenPublication) {
                from components.java
            }
        }
        if (project.hasProperty('nexusRepo')) {
            repositories {
                maven {
                    name 'nexus'
                    url "$nexusRepo/content/repositories/releases/"
                    credentials {
                        username = nexusUsername
                        password = nexusPassword
                    }
                }
            }
        }
    }

    tasks.matching { it.name.endsWith("PublicationToNexusRepository") }.all {
        onlyIf { project.hasProperty('release') && project.property('release').toBoolean() }
    }

    jacoco {
        toolVersion = "0.8.3"
    }

    jacocoTestReport {
        reports {
            html.enabled = true
        }
        executionData.from fileTree(buildDir).include("/jacoco/*.exec")
    }
}

diffCoverageReport {
    afterEvaluate {
        diffSource.url = createDiffUrl()
    }
    jacocoExecFiles = files(subprojects.jacocoTestReport.executionData)
    classesDirs = files(subprojects.jacocoTestReport.classDirectories)
    srcDirs = files(subprojects.jacocoTestReport.sourceDirectories)
    reports {
        html = true
    }

    violationRules {
        minBranches = 1
        minLines = 1
        minInstructions = 1
        failOnViolation = false
    }
}

ext.createDiffUrl = { ->
    if(project.hasProperty('teamcity')) {
        Properties properties = new Properties()
        file(project.teamcity['teamcity.configuration.properties.file']).withInputStream {
            properties.load(it)
        }
        def projectIdMatcher = properties."vcsroot.url" =~ /http:\/\/gitlab\.t1\.tenet\/(.+)\.git/
        def buildBranchMatcher = properties."teamcity.build.branch" =~ /merge-requests\/(\d+)(\/head)?/

        if (buildBranchMatcher.find() && projectIdMatcher.find()) {
            return "http://gitlab.t1.tenet/${projectIdMatcher.group(1)}/merge_requests/${buildBranchMatcher.group(1)}.diff"
        }
    }

    def file = Files.createTempFile(URLEncoder.encode(project.name, "UTF-8"), ".diff").toFile()
    def outputStream = file.newOutputStream()
    exec {
        commandLine 'git', 'diff', '@^..@'
        standardOutput = outputStream
    }
    outputStream.close()
    return file.toURI().toURL()
}
